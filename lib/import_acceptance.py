"""Strict validation and import helpers for externally generated YAML."""

import os
from typing import Any, Dict, List

import yaml

from .validators import format_validation_errors, validate_inventory
from .yaml_ops import load_yaml


_ALLOWED_ROOT_KEYS = frozenset({"meta", "inventory"})


def _error_payload(
    error_code: str,
    message: str,
    *,
    errors: List[str] = None,
    warnings: List[str] = None,
) -> Dict[str, Any]:
    errors = list(errors or [])
    warnings = list(warnings or [])
    return {
        "ok": False,
        "error_code": str(error_code or "unknown_error"),
        "message": str(message or ""),
        "report": {
            "error_count": len(errors),
            "warning_count": len(warnings),
            "errors": errors,
            "warnings": warnings,
        },
    }


def _summarize_ok(warnings: List[str]) -> str:
    warnings = list(warnings or [])
    if not warnings:
        return "Validation passed."
    return f"Validation passed with {len(warnings)} warning(s)."


def _validate_root_and_layout(data: Any) -> List[str]:
    errors: List[str] = []
    if not isinstance(data, dict):
        return ["YAML root must be an object"]

    root_keys = set(data.keys())
    missing = sorted(_ALLOWED_ROOT_KEYS - root_keys)
    extra = sorted(root_keys - _ALLOWED_ROOT_KEYS)

    for key in missing:
        errors.append(f"Missing top-level key: '{key}'")
    if extra:
        extras = ", ".join(extra)
        errors.append(f"Unsupported top-level key(s): {extras}")

    meta = data.get("meta")
    if not isinstance(meta, dict):
        errors.append("'meta' must be an object")
        return errors

    layout = meta.get("box_layout")
    if not isinstance(layout, dict):
        errors.append("meta.box_layout must be an object")
        return errors

    rows = layout.get("rows")
    cols = layout.get("cols")
    if not isinstance(rows, int) or rows <= 0:
        errors.append("meta.box_layout.rows must be a positive integer")
    if not isinstance(cols, int) or cols <= 0:
        errors.append("meta.box_layout.cols must be a positive integer")

    return errors


def validate_candidate_yaml(path: str, *, fail_on_warnings: bool = True) -> Dict[str, Any]:
    """Validate a candidate YAML file generated by external tools.

    Args:
        path: Candidate YAML path.
        fail_on_warnings: When True, warnings are treated as blocking failures.
    """
    candidate = os.path.abspath(str(path or "").strip())
    if not candidate:
        return _error_payload("invalid_path", "Candidate YAML path is required.")
    if not os.path.isfile(candidate):
        return _error_payload("file_not_found", f"Candidate YAML not found: {candidate}")

    try:
        data = load_yaml(candidate)
    except Exception as exc:
        return _error_payload("load_failed", f"Failed to load candidate YAML: {exc}")

    errors = _validate_root_and_layout(data)
    warnings: List[str] = []

    if isinstance(data, dict):
        inv_errors, inv_warnings = validate_inventory(data)
        errors.extend(inv_errors)
        warnings.extend(inv_warnings)

    if fail_on_warnings and warnings:
        errors.extend([f"Warning treated as error: {item}" for item in warnings])

    if errors:
        return _error_payload(
            "validation_failed",
            format_validation_errors(errors, prefix="Import validation failed"),
            errors=errors,
            warnings=warnings,
        )

    return {
        "ok": True,
        "message": _summarize_ok(warnings),
        "report": {
            "error_count": 0,
            "warning_count": len(warnings),
            "errors": [],
            "warnings": warnings,
        },
    }


def import_validated_yaml(
    candidate_path: str,
    target_path: str,
    *,
    mode: str = "create_new",
    overwrite: bool = False,
) -> Dict[str, Any]:
    """Import a candidate YAML file after strict validation.

    Current supported mode:
        - ``create_new``: write to a new/selected YAML path.
    """
    mode = str(mode or "create_new").strip().lower()
    if mode != "create_new":
        return _error_payload("unsupported_mode", f"Unsupported import mode: {mode}")

    validation = validate_candidate_yaml(candidate_path, fail_on_warnings=True)
    if not validation.get("ok"):
        return {
            "ok": False,
            "error_code": "validation_failed",
            "message": validation.get("message") or "Candidate YAML failed validation.",
            "report": validation.get("report") or {},
        }

    destination = os.path.abspath(str(target_path or "").strip())
    if not destination:
        return _error_payload("invalid_target_path", "Target YAML path is required.")

    suffix = os.path.splitext(destination)[1].lower()
    if suffix not in {".yaml", ".yml"}:
        return _error_payload("invalid_target_suffix", "Target path must end with .yaml or .yml")

    if os.path.exists(destination) and not overwrite:
        return _error_payload("target_exists", f"Target YAML already exists: {destination}")

    target_dir = os.path.dirname(destination)
    if target_dir:
        os.makedirs(target_dir, exist_ok=True)

    try:
        data = load_yaml(candidate_path)
        with open(destination, "w", encoding="utf-8") as handle:
            yaml.safe_dump(data, handle, allow_unicode=True, sort_keys=False)
    except Exception as exc:
        return _error_payload("write_failed", f"Failed to write imported YAML: {exc}")

    return {
        "ok": True,
        "message": "Imported validated YAML successfully.",
        "target_path": destination,
        "report": validation.get("report") or {},
    }
